;; Object semantic.cache
;; SEMANTICDB Tags save file
(semanticdb-project-database "semantic.cache"
  :file "semantic.cache"
  :tables (list 
   (semanticdb-table "find-recursive.el"
    :file "find-recursive.el"
    :pointmax 4670
    :major-mode 'emacs-lisp-mode
    :tokens '(("cl" include nil nil nil [1032 1045]) ("find-recursive-exclude-files" variable nil (quote (".*.class$" ".*~$" ".*.elc$")) nil "List of regular expressions of files to be excluded when recursively searching for files." nil [1047 1259]) ("find-file-recursively" function nil ("file-regexp" "directory") nil (interactive "sFile name to search for recursively: 
DIn directory: ") nil [1261 2138]) ("find-recursive-directory-relative-files" function nil ("directory" "relative-directory" "file-regexp") nil (let* ((full-dir (concat directory "/" relative-directory)) (matches (mapcar (function (lambda (x) (concat relative-directory x))) (find-recursive-filter-out (quote (nil)) (directory-files full-dir nil file-regexp nil t)))) (inner (mapcar (function (lambda (dir) (find-recursive-directory-relative-files directory (concat relative-directory dir "/") file-regexp))) (find-recursive-filter-out (quote (nil "\\." "\\.\\.")) (directory-files full-dir nil ".*" nil (quote directories)))))) (mapcar (function (lambda (dir) (setq matches (append matches dir)))) inner) matches) nil [2140 2900]) ("find-recursive-filter-out" function nil ("remove-list" "list") nil "Remove all the elements in *remove-list* from *list*" nil [2902 3358]) ("find-recursive-running-xemacs" variable nil (string-match "XEmacs\\|Lucid" emacs-version) nil nil nil [3360 3444]) ("if" code nil [3446 4578]) ("global-set-key" code nil [4580 4642]) ("find-recursive" package nil nil nil [4644 4669]))
    )
   (semanticdb-table "mode-compile.el"
    :file "mode-compile.el"
    :pointmax 101475
    :major-mode 'emacs-lisp-mode
    :tokens '(("compile" include nil nil nil [12639 12657]) ("byte-compile" include nil nil nil [12696 12730]) ("backquote" include nil nil nil [12751 12771]) ("cl" include nil nil nil [12772 12785]) ("load-library" code nil [12786 12810]) ("pp" include nil nil nil [12833 12846]) ("condition-case" code nil [12893 12954]) ("if" code nil [12957 13241]) ("condition-case" code nil [13310 13369]) ("if" code nil [13372 13673]) ("defgroup" code nil [13693 13911]) ("defgroup" code nil [13912 14028]) ("defgroup" code nil [14029 14117]) ("defgroup" code nil [14118 14232]) ("mode-compile-modes-alist" variable nil (quote ((c-mode cc-compile kill-compilation) (java-mode java-compile kill-compilation) (c++-mode c++-compile kill-compilation) (ada-mode ada-compile kill-compilation) (fortran-mode f77-compile kill-compilation) (dired-mode dired-compile kill-compilation) (emacs-lisp-mode elisp-compile keyboard-quit) (lisp-interaction-mode elisp-compile keyboard-quit) (makefile-mode makefile-compile kill-compilation) (sh-mode sh-compile kill-compilation) (csh-mode csh-compile kill-compilation) (zsh-mode zsh-compile kill-compilation) (perl-mode perl-compile kill-compilation) (cperl-mode perl-compile kill-compilation) (tcl-mode tcl-compile kill-compilation) (python-mode python-compile kill-compilation) (ruby-mode ruby-compile kill-compilation) (fundamental-mode guess-compile nil) (text-mode guess-compile nil) (indented-text-mode guess-compile nil) (compilation-mode default-compile kill-compilation))) nil "Assoc list of compile/kill functions for some known modes.

Each element look like (MODE . (COMPILE-FUNCTION KILL-FUNCTION))
 `mode-compile' will call COMPILE-FUNCTION and `mode-compile-kill'
 KILL-FUNCTION if current major-mode is MODE.

If you want to add or modify a COMPILE-FUNCTION and it's associated
KILL-FUNCTION for MODE and don't want to hack `mode-compile' you could
do the following (it exists however a more subtle method for
modifying, this is left as an exercice for the reader :-):
 (defun my-mode-compile() ...)
 (defun my-mode-compile-kill() ...)
 (setq mode-compile-modes-alist
       (append '((my-mode . (my-mode-compile my-mode-compile-kill)))
               mode-compile-modes-alist))" nil [14316 17756]) ("mode-compile-filename-regexp-alist" variable nil (quote ((mode-compile-makefile-regexp . makefile-mode) ("\\.sh$" . sh-mode) ("\\.csh$" . csh-mode) ("\\.zsh$" . zsh-mode))) nil "Assoc list of major-modes for some filenames regexp.

Each element look like (REGEXP . MODE) This variable is really similar
to `auto-mode-alist' in the fact that it associate a MODE to a REGEXP
matching a filename. The only differences is that you are not obliged
to have the specified MODE available to use it (`guess-compile' use
it), the MODE is only a pointer to an assoq in
`mode-compile-modes-alist' to get the COMPILE-FUNCTION and the
KILL-FUNCTION. The REGEXP could be a form wich evaluate to a string.

To add a new filename regexp do the following:
 (setq mode-compile-filename-regexp-alist
       (append '((my-filename-regexp . some-mode-mode-compile-know)
               mode-compile-modes-alist))" nil [17758 19522]) ("mode-compile-shell-alist" variable nil (quote (("sh" . sh-mode) ("csh" . csh-mode) ("zsh" . zsh-mode) ("perl" . perl-mode) ("tcl" . tcl-mode) ("python" . python-mode) ("ruby" . ruby-mode))) nil "Assoc list of compile function for some known shells.

Each element look like (SHELL . MODE) This variable look like
`auto-mode-alist' in the fact that it associate a MODE to a name; A
SHELL name here. The main difference is that you are not obliged to
have the specified MODE available to use it (`guess-compile' use it),
the MODE is only a pointer to an assoq in `mode-compile-modes-alist'
to get the COMPILE-FUNCTION and the KILL-FUNCTION.

To add a new shell do the following:
 (setq mode-compile-filename-shell-alist
       (append '((my-shell-name . some-mode-mode-compile-know)
               mode-compile-modes-alist))" nil [19524 20803]) ("mode-compile-make-program" variable nil "make" ((user-visible . t)) "*The `make' program used to process makefiles.

If you have GNU make installed with name \"gmake\" use it." nil [20820 21013]) ("mode-compile-makefile-regexp" variable nil "\\(^[Mm]akefile\\|.*\\.[mM][aA]?[kK][eE]?\\.?.*$\\)" nil "Regexp matching 'could be' makefiles filenames." nil [21015 21201]) ("mode-compile-makefile-backups-regexp" variable nil "\\(\\(~\\|\\.[bB][aA][cC]?[kK]\\)$\\)\\|\\(\\(^\\|/\\)[.,][^/]+$\\)" nil "Regexp to find if a Makefile is a backup or not" nil [21203 21413]) ("mode-compile-ignore-makefile-backups" variable nil t ((user-visible . t)) "*Tell mode compile to ignore makefiles backup files when selecting the Makefile to use." nil [21430 21611]) ("mode-compile-default-make-options" variable nil "-k" nil "Default options to give to `make'." nil [21628 21714]) ("mode-compile-make-options" variable nil (eval mode-compile-default-make-options) ((user-visible . t)) "*Options to give to `make'.
This could be any form evaluating to a string.

Some people asked me a way to modify the make options everytime a
compilation command is launched, do that:
 (defun my-mode-compile-ask-make-options()
   \"*Hook called by mode-compile, asking for make options.\"
   (interactive)
   (read-string \"Make options: \"
                mode-compile-default-make-options))
 (setq mode-compile-make-options
           'my-mode-compile-ask-make-options)" nil [21730 22393]) ("mode-compile-prefered-default-makerule" variable nil (quote none) ((user-visible . t)) "*Default makerule you would like to see in minibuffer as a default choice
when selecting the make rule to build.

Possible values are:
'none    -- let mode-compile deciding for you.
'all     -- try hard to show you the \"all\" rule.
'default -- try hard to show you the \"default\" rule.
'file    -- try to show you the name of the file which will be
            result of compilation.
The 'none action is taken as default is something fail." nil [22410 23285]) ("mode-compile-ignore-makerule-regexp" variable nil nil ((user-visible . t)) "*Makefile rules which must be ignored when building completion list.

For example if you want to remove all `files rules' set
it to: \"\\\\.\\\\([aoc]\\\\|s[ao][.0-9]*\\\\)\". " nil [23302 23721]) ("mode-compile-save-all-p" variable nil nil ((user-visible . t)) "*Non-nil means save ALL the modified buffers without asking
before launching compilation command." nil [23738 23918]) ("mode-compile-always-save-buffer-p" variable nil nil ((user-visible . t)) "*Non-nil means save the current buffer without asking
before launching compilation command." nil [23935 24119]) ("mode-compile-never-edit-command-p" variable nil nil ((user-visible . t)) "*Non-nil means never ask to user to edit the compile command." nil [24136 24290]) ("defgroup" code nil [24334 24445]) ("mode-compile-other-frame-p" variable nil nil ((user-visible . t)) "*Non-nil means compile in another frame.

A new Emacs FRAME is created and the compilation command is executed
in this other frame.  To specify the frame parameters see also
variable `mode-compile-frame-parameters-alist'." nil [24462 24775]) ("mode-compile-other-frame-name" variable nil "COMPILATION" nil "Name of mode-compile's other frame.

This name could be used in your .Xdefault or .Xresources file as:
Emacs.MODE-COMPILE-OTHER-FRAME-NAME.resource_to_be_set: ..." nil [24777 25043]) ("mode-compile-default-frame-parameters" variable nil (list (cons (quote name) mode-compile-other-frame-name) (cons (quote width) 85) (cons (quote height) 30)) ((const . t)) "Default parameters for mode-compile's other frame." nil [25045 25267]) ("mode-compile-frame-parameters-alist" variable nil (purecopy mode-compile-default-frame-parameters) nil "Parameters for the new Compilation Screen created
if variable `mode-compile-other-frame-p' is non nil..

See also variable `mode-compile-default-frame-parameters' and
`mode-compile-other-frame-name'.

For informations about Screen/Frame parameters see:
- Info, Nodes: Lispref::Screen::Screen Parameters
- GNU Emacs Lisp Reference Manual, chapter 26 p375: Frames." nil [25269 25731]) ("mode-compile-before-compile-hook" variable nil nil nil "Hook to be run before compile command is executed
when `mode-compile' is invoked." nil [25765 25935]) ("mode-compile-after-compile-hook" variable nil nil nil "Hook to be run after compile command is executed
when `mode-compile' is invoked." nil [25952 26120]) ("mode-compile-before-kill-hook" variable nil nil nil "Hook to be run before killing compile command is executed
when `mode-compile-kill' is invoked." nil [26137 26317]) ("mode-compile-after-kill-hook" variable nil nil nil "Hook to be run after killing compile command is executed
when `mode-compile-kill' is invoked." nil [26334 26512]) ("mode-compile-exe-file-ext" variable nil (cond ((memq system-type (quote (ms-dos emx windows-95 windows-98 windows-nt))) ".exe") (t "")) ((user-visible . t)) "*Extension of executable files (with dot included)" nil [26545 26731]) ("mode-compile-dir-separator-char" variable nil (cond ((memq system-type (quote (ms-dos emx windows-95 windows-98 windows-nt))) "\\") (t "/")) ((user-visible . t)) "*Separator char between directories" nil [26733 26964]) ("mode-compile-choosen-compiler" variable nil nil ((user-visible . t)) "*Global variable containing the name of the compiler
which will be used for compiling without makefile.

 Could be used in combination with
 (cc|c++|ada|f77)-default-compiler-options
to automaticaly choose the compiler specific options.

example:
 (defun my-compiler-get-options()
   (cond
    ((string= mode-compile-choosen-compiler \"gcc\")
      \"-Wall -pedantic-errors\")
    ((string= mode-compile-choosen-compiler \"cc\")
      \"cc options whatever they are...\")
    (t
     (message \"Don't know this compiler: %s\" mode-compile-choosen-compiler)
     (read-string
      (format \"Options for %s compiler: \" mode-compile-choosen-compiler)))))

  (setq cc-default-compiler-options 'my-compiler-get-options)" nil [27013 27776]) ("mode-compile-expert-p" variable nil nil ((user-visible . t)) "*Non nil means `mode-compile' will not speaks too much.

See also variable variable mode-compile-reading-time." nil [27815 28006]) ("mode-compile-reading-time" variable nil 1 ((user-visible . t)) "*Seconds to wait in verbose mode after printing a message.

In verbose mode mode-compile print too much messages that it is
allmost impossible to read them. Just setting this delay leave you the
time to read all the messages. If you don't want any delay set it to
`0'.

See also function sit-for." nil [28023 28402]) ("defgroup" code nil [28440 28528]) ("mode-compile-remote-hosts-alist" variable nil (quote nil) nil "Alist of favourites hosts names and the username
to use to log on (HOSTNAME . USERNAME).

If USERNAME is a function it will be called with HOSTNAME as argument
and should return an USERNAME string (for example you could use
something like efs-get-user - not tested -), if it is nil the function
user-login-name will be used." nil [28530 29227]) ("mode-compile-remote-execute-command" variable nil "rsh" nil "The shell command used to run a command remotely.
\"rsh\" is the only choice I know but I'm far to know everything...

 This variable is set automaticaly with the value of
remote-shell-program or efs-remote-shell-file-name at load time." nil [29229 29561]) ("eval-when" code nil [29562 30069]) ("mode-compile-remote-execute-set-host-arg" variable nil "" nil "Argument To set the remote host name to the
mode-compile-remote-execute-command,

None is required for \"rsh\"." nil [30071 30287]) ("mode-compile-remote-execute-set-command-arg" variable nil "" nil "Argument to set the command to be run remotely to the
mode-compile-remote-execute-command.

None is required for \"rsh\"." nil [30289 30518]) ("mode-compile-remote-execute-set-username-arg" variable nil "-l" nil "Argument to set the username under which we will log on
on the remote host, to give to mode-compile-remote-execute-command." nil [30520 30754]) ("mode-compile-remote-execute-misc-args" variable nil "" nil "Misc additionnals arguments to give to the
mode-compile-remote-execute-command." nil [30756 30937]) ("defgroup" code nil [30977 31067]) ("cc-compilers-list" variable nil (quote ("gcc" "c89" "acc" "cc")) nil "List of user's favourites C compilers in order of preferencies." nil [31069 31264]) ("cc-companion-file-regexp" variable nil "\\(_[Pp]\\)?\\.[pP]?h" nil "Regexp to find associated .c file from a .h." nil [31266 31411]) ("cc-default-compiler" variable nil "cc" ((user-visible . t)) "*Default C compiler to use when everything else fails.

This could be any form evaluating to a string, so you could map it to
a function asking you interactively to choose the compiler.

example:
 (defun my-choose-compiler()
   (read-string \"C compiler: \"))
 (setq cc-compilers-list '()
       cc-default-compiler 'my-choose-compiler)" nil [31413 31844]) ("cc-compiler-varenv" variable nil "CC" nil "Varenv indicating the C compiler to use." nil [31846 31962]) ("cc-cflags-varenv" variable nil "CFLAGS" nil "Varenv indicating the C compiler flags to use." nil [31964 32088]) ("cc-source-ext-list" variable nil (quote ("c")) nil "Extensions for C compileable source files." nil [32090 32221]) ("cc-headers-ext-list" variable nil (quote ("h")) nil "Extensions for C headers source files." nil [32223 32351]) ("cc-default-compiler-options" variable nil "-g" ((user-visible . t)) "*Default options to give to the C compiler.

This could be any form evaluating to a string.
See `mode-compile-choosen-compiler' variable." nil [32353 32646]) ("cc-source-file-ext-regexp" variable nil "\\.c" nil "Regexp to find, from it's name, if a C file is compileable." nil [32648 32792]) ("cc-build-output-args" variable nil t nil "Build output-args for c-mode." nil [32794 32899]) ("cc-object-file-ext" variable nil "o" nil "Extension of objects file (result of compilation)
in c mode." nil [32901 33036]) ("defgroup" code nil [33079 33163]) ("java-compilers-list" variable nil (quote ("javac")) nil "List of user's favourites java compilers in order of preferencies." nil [33165 33356]) ("java-companion-file-regexp" variable nil "" nil "Regexp to find associated compileable Java companion file.

This is useless in Java because there do not exists uncompileable files." nil [33358 33575]) ("java-default-compiler" variable nil "javac" ((user-visible . t)) "*Default C compiler to use when everything else fails.

This could be any form evaluating to a string, so you could map it to
a function asking you interactively to choose the compiler.

example:
 (defun my-choose-compiler()
   (read-string \"Java compiler: \"))
 (setq java-default-compiler 'my-choose-compiler)." nil [33577 33993]) ("java-compiler-varenv" variable nil "JAVAC" nil "Varenv indicating the C compiler to use." nil [33995 34119]) ("java-cflags-varenv" variable nil "JAVAC_FLAGS" nil "Varenv indicating the C compiler flags to use." nil [34121 34255]) ("java-source-ext-list" variable nil (quote ("java")) nil "Extensions for Java compileable source files." nil [34257 34399]) ("java-headers-ext-list" variable nil (quote ("java")) nil "Extensions for Java source files." nil [34401 34532]) ("java-default-compiler-options" variable nil "-O" ((user-visible . t)) "*Default options to give to the Java compiler.

This could be any form evaluating to a string.  See
`mode-compile-choosen-compiler' variable." nil [34534 34836]) ("java-source-file-ext-regexp" variable nil "\\.java" nil "Regexp to find, from it's name, if a Java file is compileable." nil [34838 34993]) ("java-build-output-args" variable nil nil nil "Dont build output-args for Java-mode." nil [34995 35115]) ("java-object-file-ext" variable nil "class" nil "Extension of objects file (result of compilation)
in java mode." nil [35117 35264]) ("defgroup" code nil [35306 35387]) ("c++-compilers-list" variable nil (quote ("g++" "gcc" "CC")) nil "List of user's favourites C++ compilers in order of preferencies." nil [35389 35585]) ("c++-companion-file-regexp" variable nil "\\(_[Pp]\\)?\\.\\([pP]?[Hh][Hh]?\\|[Hh]\\+\\+?\\)" nil "Regexp to find associated compileable C++ companion file
from a header file." nil [35587 35795]) ("c++-default-compiler" variable nil "CC" ((user-visible . t)) "*Default C++ compiler to use when everything else fails..

This could be any form evaluating to a string, so you could map it to
a function asking you interactively to choose the compiler.

example:
 (defun my-choose-compiler()
   (read-string \"C++ compiler: \"))
 (setq c++-default-compiler 'my-choose-compiler)" nil [35797 36208]) ("c++-compiler-varenv" variable nil "CXX" nil "Varenv indicating the C++ compiler to use." nil [36210 36332]) ("c++-cflags-varenv" variable nil "CXXFLAGS" nil "Varenv indicating the C++ compiler flags to use." nil [36334 36465]) ("c++-source-ext-list" variable nil (quote ("cc" "C" "CC" "cpp" "cxx" "c++" "c+")) nil "Extensions for C++ compileable source files." nil [36467 36636]) ("c++-headers-ext-list" variable nil (quote ("H" "hh" "HH" "h++" "h+" "h" "hpp" "hxx")) nil "Extensions for C++ headers source files." nil [36638 36808]) ("c++-default-compiler-options" variable nil "-g" ((user-visible . t)) "*Default options to give to the C++ compiler.
This could be any form evaluating to a string.  See
`mode-compile-choosen-compiler' variable." nil [36810 37108]) ("c++-source-file-ext-regexp" variable nil "\\.\\(cc\\|CC?\\|c\\+\\+?\\|cpp\\|cxx\\)" nil "Regexp to find, from it's name, if a C++ file is compileable." nil [37110 37295]) ("c++-build-output-args" variable nil t nil "Build output-args for c++-mode." nil [37297 37407]) ("c++-object-file-ext" variable nil "o" nil "Extension of objects file (result of compilation)
in c++ mode." nil [37409 37549]) ("defgroup" code nil [37591 37672]) ("ada-compilers-list" variable nil (quote ("gcc" "gnat" "ada")) nil "List of user's favourites Ada compilers in order of preferencies." nil [37674 37874]) ("ada-companion-file-regexp" variable nil "" nil "Regexp to find associated compileable Ada companion file from a spec file.

This is useless in Ada because there do not exists uncompileable files." nil [37876 38106]) ("ada-default-compiler" variable nil "ada" ((user-visible . t)) "*Default Ada compiler to use when everything else fails.

This could be any form evaluating to a string, so you could map it to
a function asking you interactively to choose the compiler.

example:
 (defun my-choose-compiler()
   (read-string \"Ada compiler: \"))
 (setq ada-default-compiler 'my-choose-compiler)" nil [38108 38519]) ("ada-compiler-varenv" variable nil "ADA" nil "Varenv indicating the Ada compiler to use." nil [38521 38643]) ("ada-aflags-varenv" variable nil "AFLAGS" nil "Varenv indicating the Ada compiler flags to use." nil [38645 38774]) ("ada-source-ext-list" variable nil (quote ("ads" "adb" "ada" "a")) nil "Extensions for Ada compileable source files." nil [38776 38930]) ("ada-headers-ext-list" variable nil (quote ("ads" "ada" "a")) nil "Extensions for Ada spec source files." nil [38932 39074]) ("ada-default-compiler-options" variable nil "-g" ((user-visible . t)) "*Default options to give to the Ada compiler.

This could be any form evaluating to a string.  See
`mode-compile-choosen-compiler' variable." nil [39076 39375]) ("ada-source-file-ext-regexp" variable nil "\\.\\(ad[abs]\\|a\\)" nil "Regexp to find, from it's name, if an Ada file is compileable.

This is useless in Ada because there do not exists uncompileable files." nil [39377 39616]) ("ada-build-output-args" variable nil t nil "Build output-args for ada-mode." nil [39618 39728]) ("ada-object-file-ext" variable nil "o" nil "Extension of objects file (result of compilation)
in ada mode." nil [39730 39870]) ("defgroup" code nil [39916 40005]) ("f77-compilers-list" variable nil (quote ("f77" "fc")) nil "List of user's favourite Fortran compilers in order of preferencies." nil [40007 40202]) ("f77-companion-file-regexp" variable nil "\\(_[Pp]\\)?\\.[pP]?inc" nil "Regexp to find associated .f file from a .inc." nil [40204 40360]) ("f77-default-compiler" variable nil "f77" ((user-visible . t)) "*Default fortran compiler to use when everything else fails..

This could be any form evaluating to a string, so you could map it to
a function asking you interactively to choose the compiler.

example:
 (defun my-choose-compiler()
   (read-string \"Fortran compiler: \"))
 (setq f77-default-compiler 'my-choose-compiler)" nil [40362 40786]) ("f77-compiler-varenv" variable nil "F77" nil "Varenv indicating the fortran compiler to use." nil [40788 40918]) ("f77-cflags-varenv" variable nil "FCOPTS" nil "Varenv indicating the fortran compiler flags to use." nil [40920 41057]) ("f77-source-ext-list" variable nil (quote ("f" "F" "for" "For")) nil "Extensions for fortran compileable source files." nil [41059 41219]) ("f77-headers-ext-list" variable nil (quote ("inc" "h")) nil "Extensions for fortran include files." nil [41221 41360]) ("f77-default-compiler-options" variable nil "-w66 -a" ((user-visible . t)) "*Default options to give to the fortran compiler.

This could be any form evaluating to a string.  See
`mode-compile-choosen-compiler' variable." nil [41362 41674]) ("f77-source-file-ext-regexp" variable nil "\\.\\([Ff]\\|for\\)" nil "Regexp to find, from it's name, if a fortran file is compileable." nil [41676 41848]) ("f77-build-output-args" variable nil t nil "Build output-args for f77-mode." nil [41850 41964]) ("f77-object-file-ext" variable nil "o" nil "Extension of objects file (result of compilation)
in Fortran mode." nil [41966 42114]) ("defgroup" code nil [42155 42259]) ("sh-command" variable nil "sh" nil "Command to run sh scripts" nil [42261 42355]) ("sh-dbg-flags" variable nil "-fvx" ((user-visible . t)) "*Flags to give to sh for debugging a Bourne Shell script.

The -f flag must always be present." nil [42357 42524]) ("sh-compilation-error-regexp-alist" variable nil nil nil "Alist that specifies how to match errors in sh output.

See variable compilation-error-regexp-alist for more details." nil [42526 42784]) ("defgroup" code nil [42825 42918]) ("csh-command" variable nil "csh" nil "Command to run csh scripts" nil [42920 43018]) ("csh-dbg-flags" variable nil "-fVX" ((user-visible . t)) "*Flags to give to csh for debugging a C Shell script.

The -f flag must always be present." nil [43020 43185]) ("csh-compilation-error-regexp-alist" variable nil nil nil "Alist that specifies how to match errors in csh output.

See variable compilation-error-regexp-alist for more details." nil [43187 43442]) ("defgroup" code nil [43483 43584]) ("zsh-command" variable nil "zsh" nil "Command to run zsh scripts" nil [43586 43684]) ("zsh-dbg-flags" variable nil "-nCvx" ((user-visible . t)) "*Flags to give to zsh for debugging a Z Shell script." nil [43686 43815]) ("zsh-compilation-error-regexp-alist" variable nil nil nil "Alist that specifies how to match errors in csh output.

See variable compilation-error-regexp-alist for more details." nil [43817 44072]) ("defgroup" code nil [44119 44202]) ("tcl-command" variable nil "wish" nil "Command to run tcl scripts" nil [44204 44303]) ("tcl-dbg-flags" variable nil "" ((user-visible . t)) "*Flags to give to tcl -- none." nil [44305 44406]) ("tcl-compilation-error-regexp-alist" variable nil (quote (("file \"\\([^ ]+\\)\" line \\([0-9]+\\)[)]" 1 2))) nil "Alist that specifies how to match errors in tcl output.

See variable compilation-error-regexp-alist for more details." nil [44408 44694]) ("defgroup" code nil [44743 44832]) ("python-command" variable nil "python" nil "Command to run python scripts" nil [44834 44944]) ("python-dbg-flags" variable nil "" ((user-visible . t)) "*Flags to give to python -- none." nil [44946 45056]) ("python-compilation-error-regexp-alist" variable nil (quote (("File \"\\([^ ]+\\)\", line \\([0-9]+\\).*" 1 2))) nil "Alist that specifies how to match errors in python output.

See variable compilation-error-regexp-alist for more details." nil [45058 45357]) ("defgroup" code nil [45399 45484]) ("perl-command" variable nil "perl" nil "Command to run perl." nil [45486 45581]) ("perl-dbg-flags" variable nil "-w" ((user-visible . t)) "*Flags to give to perl for debugging a Perl script." nil [45583 45709]) ("perl-compilation-error-regexp-alist" variable nil (quote (("in file \\([^ ]+\\) at line \\([0-9]+\\).*" 1 2) ("at \\([^ ]+\\) line \\([0-9]+\\)," 1 2) ("at \\([^ ]+\\) line \\([0-9]+\\)." 1 2))) nil "Alist that specifies how to match errors in perl output.

See variable compilation-error-regexp-alist for more details." nil [45711 46351]) ("defgroup" code nil [46393 46478]) ("ruby-command" variable nil "ruby" nil "Command to run ruby" nil [46480 46577]) ("ruby-dbg-flags" variable nil "" nil "Flags to give ruby for catching warnings" nil [46579 46695]) ("ruby-compilation-error-regexp-alist" variable nil (quote (("test[a-zA-Z0-9_]*([A-Z][a-zA-Z0-9_]*) \\[\\(.*\\):\\([0-9]+\\)\\]:" 1 2) ("\\(.*?\\)\\([0-9A-Za-z_./:-]+\\.rb\\):\\([0-9]+\\)" 2 3))) nil "Alist that specifies how to match errors in ruby output.

See variable compilation-error-regexp-alist for more details." nil [46697 47059]) ("emacs-lisp-byte-compile-dir-interactive-p" variable nil t ((user-visible . t)) "*Non-nil means when byte-compiling a directory ask for each file
needing to be recompiled or not." nil [47118 47320]) ("define-obsolete-variable-alias" code nil [47321 47445]) ("emacs-lisp-sources-regexp" variable nil (cond ((boundp (quote emacs-lisp-file-regexp)) emacs-lisp-file-regexp) (t "\\.el$")) nil "Regexp to find emacs lisp sources files." nil [47447 47667]) ("emacs-lisp-bytecomp-ext" variable nil "c" nil "Extension added to byte-compiled emacs sources files." nil [47669 47810]) ("mode-compile-version" variable nil "2.28" ((const . t)) "Current version of mode-compile package.

mode-compile.el,v 2.28 2003/04/01 13:52:47 boubaker Exp
Please send bugs-fixes/contributions/comments to boubaker@cena.fr" nil [47858 48064]) ("mode-compile-help-address" variable nil "heddy.Boubaker@cena.fr" ((const . t)) "E-Mail address of mode-compile maintainer." nil [48066 48174]) ("or" code nil [48415 48674]) ("mc--comp-lst" variable nil nil nil nil nil [48738 48772]) ("mc--def-comp" variable nil nil nil nil nil [48813 48847]) ("mc--compfile-regexp" variable nil nil nil nil nil [48855 48889]) ("mc--comp-varenv" variable nil nil nil nil nil [48897 48931]) ("mc--comp-options" variable nil nil nil nil nil [48939 48973]) ("mc--cflags-varenv" variable nil nil nil nil nil [48981 49015]) ("mc--source-ext-lst" variable nil nil nil nil nil [49023 49057]) ("mc--head-ext-lst" variable nil nil nil nil nil [49065 49099]) ("mc--source-ext-regexp" variable nil nil nil nil nil [49107 49141]) ("mc--build-op-args" variable nil nil nil nil nil [49149 49183]) ("mc--outfile-ext" variable nil nil nil nil nil [49191 49225]) ("mc--efs-path-list" variable nil nil nil nil nil [49250 49286]) ("mc--remote-host" variable nil nil nil nil nil [49287 49323]) ("mc--remote-host-history" variable nil nil nil nil nil [49324 49360]) ("mc--remote-username" variable nil nil nil nil nil [49361 49397]) ("mc--remote-command" variable nil nil nil nil nil [49398 49434]) ("mc--remote-pathname" variable nil nil nil nil nil [49435 49471]) ("mc--other-frame" variable nil nil nil nil nil [49497 49525]) ("mc--ws" variable nil (or (and (fboundp (quote console-type)) (console-type)) (and (fboundp (quote device-type)) (device-type)) window-system) nil nil nil [49526 49697]) ("mc--compile-command" variable nil nil nil nil nil [49699 49731]) ("make-variable-buffer-local" code nil [49946 49995]) ("mc--kill-compile" variable nil nil nil nil nil [49997 50026]) ("make-variable-buffer-local" code nil [50089 50135]) ("mc--selected-makefile" variable nil nil nil nil nil [50137 50171]) ("mc--selected-makefile-history" variable nil nil nil nil nil [50172 50214]) ("make-variable-buffer-local" code nil [50428 50479]) ("mc--selected-makerule" variable nil nil nil nil nil [50481 50515]) ("mc--selected-makerule-history" variable nil nil nil nil nil [50516 50558]) ("make-variable-buffer-local" code nil [50751 50802]) ("mc--find-C-main-regexp" variable nil "^[ 	]*\\(int\\|void\\)?[ 	
]*main[ 	
]*(+" ((const . t)) nil nil [50804 50890]) ("mc--makefile-rules-regexp" variable nil "^
*\\([^.$ 	#
][^$ 	#
:]*\\)[ 	]*:" ((const . t)) nil nil [50946 51027]) ("mc--makefile-rules" variable nil nil nil nil nil [51156 51187]) ("make-variable-buffer-local" code nil [51233 51281]) ("mc--mkfl-buffer-tick" variable nil nil nil nil nil [51283 51316]) ("make-variable-buffer-local" code nil [51385 51435]) ("mc--shell-args" variable nil nil nil nil nil [51437 51464]) ("make-variable-buffer-local" code nil [51666 51710]) ("mc--lucid-emacs-p" variable nil (or (string-match "Lucid" emacs-version) (string-match "XEmacs" emacs-version)) ((const . t)) nil nil [51768 51909]) ("if" code nil [51953 52045]) ("mc--compile" function nil ("compile-command") nil (if (null mc--remote-command) (mc--compile-sav compile-command) (let ((thisdir (expand-file-name (or default-directory "~")))) (mc--compile-sav (concat mc--remote-command "'( cd " thisdir " ; " compile-command " )'")))) nil [52047 52618]) ("mc--msg" function nil ("msg" "&rest" "args") nil (cond ((not mode-compile-expert-p) (apply (quote message) (concat "mode-compile: " msg) args) (sit-for mode-compile-reading-time))) nil [52620 52894]) ("cond" code nil [52896 54063]) ("mc--funcall" function nil ("command" "&rest" "params") nil (cond ((and (eq mc--ws (quote x)) mode-compile-other-frame-p) (mc--msg "Switching to another frame to compile...") (let ((buffer (current-buffer)) (win-attr (or mode-compile-frame-parameters-alist mode-compile-default-frame-parameters)) (frame (cond ((fboundp (quote mc--frame-live-p)) (if (mc--frame-live-p mc--other-frame) mc--other-frame nil)) (t (mc--msg "Don't know how to check frame existence.") nil)))) (cond ((fboundp (quote mc--make-frame)) (mc--select-frame (or frame (setq mc--other-frame (mc--make-frame win-attr)))) (mc--make-frame-visible mc--other-frame) (mc--raise-frame mc--other-frame) (switch-to-buffer buffer)) (t (mc--msg "Don't know how to create a new frame.")))))) nil [54065 55701]) ("mc--byte-compile-buffer" function nil nil nil (if (fboundp (quote byte-compile-buffer)) (byte-compile-buffer) (let ((tmp-file (concat (or (getenv "TMPDIR") (concat mode-compile-dir-separator-char "tmp")) mode-compile-dir-separator-char (make-temp-name "mc--")))) (save-restriction (widen) (write-region (point-min) (point-max) tmp-file) (condition-case err (byte-compile-file tmp-file) (error (mc--msg "Failing to byte-compile %s, #error %s" (buffer-name) err))) (delete-file tmp-file) (let ((elc-file (concat tmp-file emacs-lisp-bytecomp-ext))) (if (file-writable-p elc-file) (condition-case err (delete-file elc-file) (error (mc--msg "Failing to delete %s, #error %s" elc-file err))))) (message nil)))) nil [55703 56792]) ("fset" code nil [56816 57165]) ("fset" code nil [57167 57488]) ("mc--read-string" function nil ("prompt" "&optional" "initial-contents") nil (if mc--lucid-emacs-p (read-string prompt initial-contents (quote compile-history)) (read-string prompt initial-contents)) nil [57490 57786]) ("mc--eval" function nil ("sym" "&optional" "arg") nil (\` (cond ((and (symbolp (\, sym)) (fboundp (\, sym))) (funcall (\, sym) (\, arg))) (t (eval (\, sym))))) nil [57788 57988]) ("mc--common-completion" function nil ("alist") nil (\` (try-completion "" (\, alist))) nil [57990 58149]) ("mc--byte-recompile-files" function nil ("files") nil (let ((tmp-fl files)) (while (car-safe tmp-fl) (let* ((el-file (car tmp-fl)) (elc-file (concat el-file emacs-lisp-bytecomp-ext))) (mc--msg "Checking file %s ..." el-file) (if (and (file-newer-than-file-p el-file elc-file) (or (not emacs-lisp-byte-compile-dir-interactive-p) (y-or-n-p (format "byte-recompile file %s? " el-file)))) (condition-case err (byte-compile-file el-file) (error (mc--msg "Failing to byte-compile %s, #error %s" el-file err)))) (setq tmp-fl (cdr-safe tmp-fl)))) (mc--msg "All files processed")) nil [58151 59050]) ("mc--which" function nil ("file") nil (if (not (stringp file)) (error "mc--which: nil FILE arg")) nil [59052 60099]) ("mc--find-compiler" function nil nil nil (mc--msg "Searching for your favourite %s compiler ..." mode-name) nil [60101 60623]) ("mc--find-to-compile-file" function nil ("&optional" "fname") nil (let ((file-name (or fname (buffer-file-name) (error "Compilation abort: Buffer %s has no filename." (buffer-name)))) (assoc-file nil) (found nil) (pos 0)) (cond ((string-match mc--source-ext-regexp file-name) (file-name-nondirectory file-name)) ((setq pos (string-match mc--compfile-regexp file-name)) (let ((tmp-ext-lst mc--source-ext-lst)) (mc--msg "Looking for a compileable companion file for %s..." (file-name-nondirectory file-name)) (while (and tmp-ext-lst (not (setq found (file-readable-p (setq assoc-file (concat (substring file-name 0 pos) "." (car tmp-ext-lst))))))) (setq tmp-ext-lst (cdr tmp-ext-lst)))) (if found (file-name-nondirectory assoc-file) (mc--msg "Couldn't find any compileable companion file for %s ..." (file-name-nondirectory file-name)) nil)) (t (error "Compilation abort: Don't know how to compile %s." (file-name-nondirectory file-name))))) nil [60625 62366]) ("mc--guess-compile-result-fname" function nil ("infile") nil (let ((base-fname (substring infile 0 (string-match mc--source-ext-regexp infile)))) (save-excursion (set-buffer (find-file-noselect infile)) (save-excursion (save-restriction (widen) (goto-char (point-min)) (if (re-search-forward mc--find-C-main-regexp (point-max) t) (concat base-fname mode-compile-exe-file-ext) (concat base-fname "." mc--outfile-ext)))))) nil [62368 63286]) ("mc--build-output-args" function nil ("infile") nil (mc--msg "Looking into %s to build compile command ..." infile) nil [63288 63811]) ("mc--set-remote-cmd" function nil ("remote-host" "&optional" "username" "pathname") nil (if (stringp remote-host) (let ((host-infos (assoc remote-host mode-compile-remote-hosts-alist))) (setq mc--remote-host remote-host) (setq mc--remote-username (or username (let ((usrnam (cdr host-infos))) (if usrnam (cond ((stringp usrnam) usrnam) ((functionp usrnam) (funcall usrnam mc--remote-host)) (t (mc--msg "%s is not a valid option using user-login-name" (pp-to-string usrnam)) (user-login-name))) (user-login-name))))) (setq mc--remote-pathname pathname) (or host-infos (setq mode-compile-remote-hosts-alist (append (list (list remote-host)) mode-compile-remote-hosts-alist))) (setq mc--remote-command (concat mode-compile-remote-execute-command " " mode-compile-remote-execute-set-host-arg " " mc--remote-host " " mode-compile-remote-execute-set-username-arg " " mc--remote-username " " mode-compile-remote-execute-misc-args " " mode-compile-remote-execute-set-command-arg " "))) (let ((rhost (completing-read "Remote host to compile to: " mode-compile-remote-hosts-alist nil nil (or mc--remote-host (car-safe (car-safe mode-compile-remote-hosts-alist))) mc--remote-host-history))) (or (string= rhost "") (mc--set-remote-cmd rhost)))) nil [63813 66252]) ("mc--makefile-test-p" function nil ("makefile") nil (cond ((or (not makefile) (string-equal makefile "")) (mc--msg "Empty makefile selection") nil) ((file-directory-p makefile) (mc--msg "Makefile selection %s is a directory !!" makefile) nil) ((not (file-readable-p makefile)) (mc--msg "Makefile %s unreadable" makefile) nil) (t)) nil [66472 66835]) ("if" code nil [66838 67095]) ("mc--get-makefile-rules" function nil ("makefile") nil (if (or (not mc--mkfl-buffer-tick) (not (equal mc--mkfl-buffer-tick (buffer-modified-tick)))) (save-excursion (save-restriction (widen) (goto-char (point-min)) (setq mc--mkfl-buffer-tick (buffer-modified-tick)) (setq mc--makefile-rules nil) (mc--msg "Extracting rules from %s ..." makefile) (while (re-search-forward mc--makefile-rules-regexp nil t) (let ((rule (buffer-substring (match-beginning 1) (match-end 1)))) (if (and (or (not mode-compile-ignore-makerule-regexp) (not (string-match mode-compile-ignore-makerule-regexp rule))) (not (mc--member rule mc--makefile-rules))) (setq mc--makefile-rules (append mc--makefile-rules (list rule)))))))) (mc--msg "Rules had already been extracted from %s ..." makefile)) nil [67097 68601]) ("mc--makerule-completion" function nil ("alist" "outfile" "&optional" "pref") nil (let ((preference (or pref mode-compile-prefered-default-makerule))) (mc--msg "Prefered makerule choice is '%s" preference) (cond ((eq preference (quote none)) (or (mc--common-completion alist) "")) ((eq preference (quote all)) (if (assoc "all" alist) "all" (mc--makerule-completion alist outfile (quote none)))) ((eq preference (quote file)) (or outfile (mc--makerule-completion alist outfile (quote none)))) ((eq preference (quote default)) (if (assoc "default" alist) "default" "")) (t (mc--msg "Invalid `mode-compile-prefered-default-makerule': '%s" mode-compile-prefered-default-makerule) (mc--makerule-completion alist outfile (quote none))))) nil [68603 69685]) ("mc--choose-makefile-rule" function nil ("makefile" "&optional" "outfile") nil (save-excursion (set-buffer (find-file-noselect makefile)) (setq mc--selected-makerule (let* ((mk-rules-alist (mc--get-makefile-rules makefile)) (choices (mapcar (quote (lambda (x) (list x))) (if (or (not outfile) (mc--member outfile mk-rules-alist)) mk-rules-alist (append mk-rules-alist (list outfile)))))) (completing-read (if mode-compile-expert-p "Make rule: " "Using `make', enter rule to rebuild ([TAB] to complete): ") choices nil nil (or mc--selected-makerule (mc--makerule-completion choices outfile (if outfile (quote file)))) mc--selected-makerule-history)))) nil [69687 71046]) ("mc--cleanup-makefile-list" function nil ("makefile-list") nil (\` (let ((newlist)) (mapcar (quote (lambda (x) (if (and (mc--makefile-test-p x) (or (not mode-compile-ignore-makefile-backups) (not (string-match mode-compile-makefile-backups-regexp x)))) (setq newlist (cons x newlist)) (mc--msg "Removing makefile \"%s\" from completion list" x)))) (\, makefile-list)) newlist)) nil [71048 71659]) ("mc--makefile-to-use" function nil ("&optional" "directory") nil (let ((makefile-list (mc--cleanup-makefile-list (directory-files (or directory default-directory) nil mode-compile-makefile-regexp t)))) (cond ((not makefile-list) nil) ((and (not (cdr-safe makefile-list)) (mc--makefile-test-p (car makefile-list))) (car makefile-list)) (t (let ((choices (mapcar (quote (lambda (x) (list x))) makefile-list)) (makefile nil)) (while (not (mc--makefile-test-p (setq makefile (completing-read (if mode-compile-expert-p "Makefile: " "Using `make', select makefile to use ([TAB] to complete): ") choices nil t (or mc--selected-makefile (mc--common-completion choices)) mc--selected-makefile-history))))) makefile)))) nil [71661 73323]) ("mc--set-command" function nil ("&optional" "file") nil (setq completion-ignore-case nil) nil [73325 75492]) ("mc--shell-compile" function nil ("shell" "dbgflags" "&optional" "errors-regexp-alist") nil (let* ((shcmd (or (mc--which shell) (error "Compilation abort: command %s not found" shell))) (shfile (or mc--remote-pathname (buffer-file-name) (error "Compilation abort: Buffer %s has no filename" (buffer-name)))) (run-cmd (concat shcmd " " dbgflags " " shfile " " (setq mc--shell-args (read-string (if mode-compile-expert-p "Argv: " (format "Arguments to %s %s script: " shfile shell)) mc--shell-args))))) (if errors-regexp-alist (progn (or (listp errors-regexp-alist) (error "Compilation abort: In mc--shell-compile errors-regexp-alist not a list.")) (mapcar (quote (lambda (x) (if (mc--member x compilation-error-regexp-alist) nil (setq compilation-error-regexp-alist (append (list x) compilation-error-regexp-alist))))) errors-regexp-alist))) (mc--compile run-cmd)) nil [75494 77133]) ("mc--assq-get-fcomp" function nil ("asq") nil (\` (let* ((mode (cdr (\, asq))) (massq (assq mode mode-compile-modes-alist))) (if massq (car-safe (cdr massq))))) nil [77135 77353]) ("mc--assq-get-fkill" function nil ("asq") nil (\` (let* ((mode (cdr (\, asq))) (massq (assq mode mode-compile-modes-alist))) (if massq (car-safe (cdr-safe (cdr massq)))))) nil [77355 77589]) ("mc--lookin-for-shell" function nil nil nil (mc--msg "Looking if buffer %s is a shell script..." (buffer-name)) nil [77591 78422]) ("mc--lookat-name" function nil nil nil (mc--msg "Trying to guess compile command from buffer %s file name..." (buffer-name)) nil [78424 79317]) ("cc-compile" function nil nil nil "Run `compile' with a dynamically built command for `c-mode'.

The command is built depending of the existence of a makefile (which could
be specified by changing value of variable mode-compile-makefile-regexp) in
the current directory or not.
If no makefile is found try to run a C compiler on the file or it's companion.

See also variables:
 -- cc-compilers-list
 -- cc-default-compiler
 -- cc-companion-file-regexp
 -- cc-compiler-varenv
 -- cc-cflags-varenv
 -- cc-source-ext-list
 -- cc-headers-ext-list
 -- cc-source-file-ext-regexp" nil [79355 80473]) ("java-compile" function nil nil nil "Run `compile' with a dynamically built command for `java-mode'.

The command is built depending of the existence of a makefile (which could
be specified by changing value of variable mode-compile-makefile-regexp) in
the current directory or not.
If no makefile is found try to run a Java compiler on the file or it's
companion.

See also variables:
 -- java-compilers-list
 -- java-default-compiler
 -- java-companion-file-regexp
 -- java-compiler-varenv
 -- java-cflags-varenv
 -- java-source-ext-list
 -- java-headers-ext-list
 -- java-source-file-ext-regexp" nil [80475 81639]) ("c++-compile" function nil nil nil "Run `compile' with a dynamically built command for `c++-mode'.

The command is built depending of the existence of a makefile (which could
be specified by changing value of variable mode-compile-makefile-regexp) in
the current directory or not.
If no makefile is found try to run a C++ compiler on the file or it's companion.

See also variables:
 -- c++-compilers-list
 -- c++-default-compiler
 -- c++-companion-file-regexp
 -- c++-compiler-varenv
 -- c++-cflags-varenv
 -- c++-source-ext-list
 -- c++-headers-ext-list
 -- c++-source-file-ext-regexp" nil [81641 82783]) ("ada-compile" function nil nil nil "Run `compile' with a dynamically built command for `ada-mode'.

The command is built depending of the existence of a makefile (which could
be specified by changing value of variable mode-compile-makefile-regexp) in
the current directory or not.
If no makefile is found try to run an Ada compiler on the file.

See also variables:
 -- ada-compilers-list
 -- ada-default-compiler
 -- ada-companion-file-regexp
 -- ada-compiler-varenv
 -- ada-aflags-varenv
 -- ada-source-ext-list
 -- ada-headers-ext-list
 -- ada-source-file-ext-regexp)" nil [82786 83912]) ("f77-compile" function nil nil nil "Run `compile' with a dynamically built command for `fortran-mode'.

The command is built depending of the existence of a makefile (which could
be specified by changing value of variable mode-compile-makefile-regexp) in
the current directory or not.
If no makefile is found try to run a Fortran compiler on the file or it's companion..

See also variables:
 -- f77-compilers-list
 -- f77-default-compiler
 -- f77-companion-file-regexp
 -- f77-compiler-varenv
 -- f77-cflags-varenv
 -- f77-source-ext-list
 -- f77-headers-ext-list
 -- f77-source-file-ext-regexp)" nil [83915 85067]) ("elisp-compile" function nil nil nil "Run `byte-compile' on the current Emacs lisp buffer.
For `emacs-lisp-mode' and `lisp-interaction-mode'.

Produce a `.elc' file if possible or `byte-compile' only the buffer." nil [85070 85607]) ("makefile-compile" function nil ("&optional" "makefile") nil "Run `make' on the current-buffer (`makefile-mode').

The user is prompted for a selection of make rules to build." nil [85610 86266]) ("dired-compile" function nil nil nil "Run `make' if a Makefile is present in current directory (`dired-mode').

The user is prompted for a selection of a makefile to choose if many
matching `mode-compile-makefile-regexp' are present in the directory and
for the make rules to build. If directory contain no makefile the function
try to find if there are some un-byte-compiled .el files and recompile them
if needed.
Ask for the complete `compile-command' if no makefile and no .el files found." nil [86269 87404]) ("sh-compile" function nil nil nil "Run `sh-command' (Bourne Shell) with `sh-dbg-flags' on current-buffer (`sh-mode').

User is prompted for arguments to run his sh program with.
If you want to step throught errors set the variable `sh-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or sh-compilation-error-regexp-alist." nil [87407 87880]) ("csh-compile" function nil nil nil "Run `csh-command' (C Shell) with `csh-dbg-flags' on current-buffer (`csh-mode').

User is prompted for arguments to run his csh program with.
If you want to step throught errors set the variable `csh-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or csh-compilation-error-regexp-alist." nil [87883 88361]) ("zsh-compile" function nil nil nil "Run `zsh-command' (Z Shell) with `zsh-dbg-flags' on current-buffer (`zsh-mode').

User is prompted for arguments to run his zsh program with.
If you want to step throught errors set the variable `zsh-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or zsh-compilation-error-regexp-alist." nil [88364 88842]) ("perl-compile" function nil nil nil "Run Perl with `perl-dbg-flags' on current-buffer (`perl-mode').

User is prompted for arguments to run his perl program with.
If you want to step throught errors set the variable `perl-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or perl-compilation-error-regexp-alist." nil [88845 89313]) ("tcl-compile" function nil nil nil "Run `tcl-command' with `tcl-dbg-flags' on current-buffer (`tcl-mode').

User is prompted for arguments to run his Tcl/Tk program with.
If you want to step throught errors set the variable `tcl-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or tcl-compilation-error-regexp-alist." nil [89316 89796]) ("python-compile" function nil nil nil "Run `python-command' with `python-dbg-flags' on current-buffer (`python-mode').

User is prompted for arguments to run his Python program with.
If you want to step throught errors set the variable `python-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or python-compilation-error-regexp-alist." nil [89799 90305]) ("ruby-compile" function nil nil nil "Run `ruby-command' with `ruby-dbg-flags' on current-buffer (`ruby-mode').

User is prompted for arguments to run their ruby program with.
If you want to step throught errors set the variable `ruby-compilation-error-regexp-alist'
to a value understandable by compile's `next-error'.
See variables compilation-error-regexp-alist or ruby-compilation-error-regexp-alist." nil [90307 90797]) ("default-compile" function nil nil nil "Default function invoked by `mode-compile' (\\[mode-compile])
when everything else failed.

Ask to user to edit `compile-command' and run `compile' (\\[compile]) with it." nil [90799 91276]) ("mc--makefile" variable nil nil nil nil nil [91278 91299]) ("guess-compile" function nil nil nil "Try to guess how to compile current-buffer.

When the compile command could not be extrapolated from major-mode this function
is called which try to guess from number of parameters which command to build.
The steps to guess which command to use to compile are:
  1st : Look into the file to check if it is a shell script
        See variable mode-compile-shell-alist
  2nd : Try to guess from the file name
        See variable mode-compile-filename-regexp-alist
  3rd : Look for a makefile in the current directory
        See variable mode-compile-makefile-regexp
  Last: Give up and ask user for the command to use
        See function default-compile" nil [91334 92912]) ("and" code nil [93014 93093]) ("mode-compile-submit-bug-report" function nil nil ((user-visible . t)) "*Submit via mail a bug report on mode-compile v2.27." nil [93110 94396]) ("mode-compile" function nil ("&optional" "remote-host") ((user-visible . t)) "*Compile the file in the current buffer with a dynamically built command.

The command is built according to the current major mode the function
was invoked from.

Running this command preceded by universal-argument (\\[universal-argument])
allows remote compilation, the user is prompted for a host name to run the
compilation command on.

Currently know how to compile in:
 `c-mode' ,              -- function cc-compile.
 `java-mode' ,           -- function java-compile.
 `c++-mode',             -- function c++-compile.
 `ada-mode',             -- function ada-compile.
 `fortran-mode',         -- function f77-compile.
 `emacs-lisp-mode'       -- function elisp-compile.
 `lisp-interaction-mode' -- function elisp-compile.
 `makefile-mode'         -- function makefile-compile.
 `dired-mode'            -- function dired-compile.
 `sh-mode'               -- function sh-compile.
 `csh-mode'              -- function csh-compile.
 `zsh-mode'              -- function zsh-compile.
 `perl-mode'             -- function perl-compile.
 `cperl-mode'            -- function perl-compile.
 `tcl-mode'              -- function tcl-compile.
 `python-mode'           -- function python-compile.
 `ruby-mode'             -- function ruby-compile.
 `fundamental-mode'      -- function guess-compile.
 `text-mode'             -- function guess-compile.
 `indented-text-mode'    -- function guess-compile.
 `compilation-mode'      -- function default-compile.
 The function `guess-compile' is called when mode is unknown.

The variable `mode-compile-modes-alist' contain description of known
modes.  The hooks variables `mode-compile-before-compile-hook' and
`mode-compile-after-compile-hook' are run just before and after
invoking the compile command of the mode.

Use the command `mode-compile-kill' (\\[mode-compile-kill]) to abort a
running compilation.

Bound on \\[mode-compile]." nil [94415 98754]) ("mode-compile" package nil nil nil [98756 98779]) ("mode-compile-kill" function nil nil ((user-visible . t)) "*Kill the running compilation launched by `mode-compile' (\\[mode-compile]) command.

The compilation command is killed according to the current major mode
the function was invoked from.

Currently know how to kill compilations from:
 `c-mode' ,              -- function kill-compilation.
 `java-mode' ,           -- function kill-compilation.
 `c++-mode' ,            -- function kill-compilation.
 `ada-mode' ,            -- function kill-compilation.
 `fortran-mode' ,        -- function kill-compilation.
 `emacs-lisp-mode'       -- function keyboard-quit.
 `lisp-interaction-mode' -- function keyboard-quit.
 `makefile-mode'         -- function kill-compilation.
 `dired-mode'            -- function kill-compilation.
 `sh-mode'               -- function kill-compilation.
 `csh-mode'              -- function kill-compilation.
 `zsh-mode'              -- function kill-compilation.
 `perl-mode'             -- function kill-compilation.
 `cperl-mode'            -- function kill-compilation.
 `tcl-mode'              -- function kill-compilation.
 `python-mode'           -- function kill-compilation.
 `ruby-mode'             -- function kill-compilation.
 `fundamental-mode'      -- Bound dynamically.
 `text-mode'             -- Bound dynamically.
 `indented-text-mode'    -- Bound dynamically.
 `compilation-mode'      -- function kill-compilation.

The variable `mode-compile-modes-alist' contain description of ALL
known modes.  The hooks variables `mode-compile-before-kill-hook' and
`mode-compile-after-kill-hook' are run just before and after invoking
the kill compile command of the mode.

Bound on \\[mode-compile-kill]." nil [98798 101318]) ("mode-compile-kill" package nil nil nil [101320 101348]))
    )
   )
  )
